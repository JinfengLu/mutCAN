#!/usr/local/bin/perl -w
# Bookmarks: 0,0 0,0 0,0 0,138 0,0 0,0 0,0 0,0 0,0 0,138
### This program turn mapping result ./mapping/$ARGV[0] to a coverage&nucleotide variation array .can file (./CAN/$ARGV[1])
### First divide $ARGV[0] by $ARGV[2] nucleotide per subfile to reduce memory usage
### output $ARGV[1] contain information for chromosome $ARGV[3], from position $ARGV[4] to $ARGV[5]
### If undefined $ARGV[4..5], $ARGV[1] will contain information for the whole chromosome $ARGV[3]
### If undefined $ARGV[3..5], $ARGV[1] will contain information for the whole genome as ./genome_size.txt (generated by previous programs) shows
### If a mismatch happens within 3 nt ($mislength) at terminals, the mismatch and the terminal will be excluded for CAN building

sub turnbowtietoarray {
    ### make the bowtie result (./mapping/$_[3]) into a array file .can (./$_[4]), focusing on chromosome $_[0], from position $_[1] to $_[2]

    open (input_data, "<./mapping/$_[3]") or die "Couldn't open: $!";
    my $temp="";
    my @tempdata=();
    my $i=0;
    my $j=0;
    my @mismatches=();
    ### $mismatches[$i][0] stores coverage nt counts at genome position $i (start from 1)
    ### $mismatches[$i][1-4] stores counts for each type of nucleotide at genome position $i (start from 1)
    ### Only store counts as the nucleotides on plus strand
    ### $j=1 A
    ### $j=2 T
    ### $j=3 C
    ### $j=4 G
    ### $mismatches[$i][5] stores coverage nt counts bridging genome position $i~$i+1 (start from 1)
    my $tempnum=0;
    my $nt="";
    for ($i=1;$i<=$_[2]-$_[1]+1;$i++) {
          for ($j=0;$j<=5;$j++) {
                $mismatches[$i][$j]=0;
          }
    }
    my $trun5=0;
    my $trun3=0;
    my @mis=();
    my $mislength=3;
    my @ntstr=();
    if (-s "./mapping/$_[3]") {
         while (1) {
                chomp ($temp=<input_data>);
                @tempdata=();
                @tempdata=split /\s+/, $temp;
                ### [0] seqID_maphit, will be turned to contributed coverage (=1/maphit)
                ### [1] strand
                ### [2] segmentID, "gi|" will be deleted
                ### [3] 5' start on + strand where the siRNA is mapped, no matter on + or -, will start from pos 1 after ++
                ### [4] seq on +
                ### [5] mismatches
                ### This is complex. For example, ACACAaGAAGtATGAcTGATTAA mapping to AAAATTAATCAaTCATtCTTCaTGTGTAAAAAA returns this
                ### [0] - [2] 4(change to 5 because a ++ above) TTAATCAGTCGTACTTCTTGTGT 5:A>T,10:T>A,15:A>G
                if ($tempdata[2]=~/^gi\|/) {
                    $tempdata[2]=$';
                }
                if ($tempdata[2] eq $_[0]) {
                    $trun5=0;
                    $trun3=0;
                    @mis=();
                    if ($#tempdata==5) {
                          @mis=split /,/, $tempdata[5];
                          for ($j=0;$j<=$#mis;$j++) {
                                $mis[$j]=~/:/;
                                if ($`<=($mislength-1)) {
                                     if (($tempdata[1] eq "+") and (($`+1)>$trun5)) {
                                           $trun5=$`+1;
                                     } elsif (($tempdata[1] eq "-") and (($`+1)>$trun3)) {
                                           $trun3=$`+1;
                                     }
                                } elsif ($`>=(length($tempdata[4])-$mislength)) {
                                     if (($tempdata[1] eq "+") and ((length($tempdata[4])-$`)>$trun3)) {
                                           $trun3=length($tempdata[4])-$`;
                                     } elsif (($tempdata[1] eq "-") and ((length($tempdata[4])-$`)>$trun5)) {
                                           $trun5=length($tempdata[4])-$`;
                                     }
                                }
                          }
                    }
                    $tempdata[3]++;
                    $tempdata[0]=~/_\d+$/;
                    $tempdata[0]=$&;
                    $tempdata[0]=~/_/;
                    $tempdata[0]=1/$';
                    @ntstr=();
                    @ntstr=unpack("A1" x (length($tempdata[4])/1),$tempdata[4]);
                    for ($j=$tempdata[3]+$trun5;$j<=$tempdata[3]+length($tempdata[4])-1-$trun3;$j++) {
                          if (($j<$_[1]) or ($j>$_[2])) {
                                next;
                          } else {
                                $tempnum=$j-$_[1]+1;
                                $mismatches[$tempnum][0]=$mismatches[$tempnum][0]+$tempdata[0];
                                if ($j<($tempdata[3]+length($tempdata[4])-1-$trun3)) {
                                     $mismatches[$tempnum][5]=$mismatches[$tempnum][5]+$tempdata[0];
                                }
                                $nt=$ntstr[$j-$tempdata[3]];
                                if ($nt eq "A") {
                                     $mismatches[$tempnum][1]=$mismatches[$tempnum][1]+$tempdata[0];
                                } elsif ($nt eq "T") {
                                     $mismatches[$tempnum][2]=$mismatches[$tempnum][2]+$tempdata[0];
                                } elsif ($nt eq "C") {
                                     $mismatches[$tempnum][3]=$mismatches[$tempnum][3]+$tempdata[0];
                                } elsif ($nt eq "G") {
                                     $mismatches[$tempnum][4]=$mismatches[$tempnum][4]+$tempdata[0];
                                }
                          }
                    }
                }
                if (eof) {
                    last;
                }
         }
    }
    close (input_data);

    open (output_result, ">./$_[4]") or die "Couldn't open: $!";
    for ($i=1;$i<=$_[2]-$_[1]+1;$i++) {
          if ($mismatches[$i][0]>=100) {
                $cover[10]++;
          } else {
                $cover[int($mismatches[$i][0]/10)]++;
                $genomesize100++;
                $totalcoverage100=$totalcoverage100+$mismatches[$i][0];
          }
          if ($mismatches[$i][0]>0) {
                $covered++;
                $totalcoverage=$totalcoverage+$mismatches[$i][0];
          }
          $temp=join "_",($_[0],$_[1]-1+$i);
          print output_result "$temp";
          for ($j=0;$j<=5;$j++) {
                $temp=sprintf("%.2f",$mismatches[$i][$j]);
                print output_result " $temp";
          }
          print output_result "\n";
    }
    close (output_result);
    system("rm ./mapping/$_[3]");

}


$divide=$ARGV[2];
open (input_genome, "<./genome_size.txt") or die "Couldn't open: $!";
my @chrtodo=();
my %chrorder=();
my @start=();
my @end=();
my $str="";
my @strdata=();
while (1) {
       chomp ($str=<input_genome>);
       if ($str ne "") {
            @strdata=();
            @strdata=split /\s+/, $str;
            if ($#ARGV==2) {
                  $chrorder{$strdata[0]}=$#chrtodo+1;
                  $chrtodo[$#chrtodo+1]=$strdata[0];
                  $start[$#start+1]=1;
                  $end[$#end+1]=$strdata[2];
            } elsif ($strdata[0] eq $ARGV[3]) {
                  $chrorder{$strdata[0]}=$#chrtodo+1;
                  $chrtodo[$#chrtodo+1]=$strdata[0];
                  if ($#ARGV>3) {
                        $start[$#start+1]=$ARGV[4];
                        $end[$#end+1]=$ARGV[5];
                  } else {
                        $start[$#start+1]=1;
                        $end[$#end+1]=$strdata[2];
                  }
            }
       }
       if (eof) {
            last;
       }
}
close (input_genome);

my $i=0;
my $j=0;
my @max=();
my $genomesize=0;
my $file="";
my $handle="";
$covered=0;
$genomesize100=0;
$totalcoverage=0;
$totalcoverage100=0;
@cover=();
for ($j=0;$j<=10;$j++) {
       $cover[$j]=0;
}
for ($j=0;$j<=$#chrtodo;$j++) {
       $genomesize=$genomesize+$end[$j]-$start[$j]+1;
       $max[$j]=int(($end[$j]-$start[$j])/$divide)+1;
       for ($i=1;$i<=$max[$j];$i++) {
             $file=join "",($chrtodo[$j],"_f",$i,".map");
             $handle=join "",("output_",$chrtodo[$j],"_",$i);
             open ($handle, ">./mapping/$file") or die "Couldn't open: $!";
       }
}

my $temp="";
my @tempdata=();
my $writestart=0;
my $writeend=0;
my $count=0;
print "Dividing mapping result\n";
open (input_data, "<./mapping/$ARGV[0]") or die "Couldn't open: $!";
if (-s "./mapping/$ARGV[0]") {
         while (1) {
                chomp ($temp=<input_data>);
                @tempdata=();
                @tempdata=split /\s+/, $temp;
                ### [2] segmentID, "gi|" will be deleted
                ### [3] 5' start on + strand where the siRNA is mapped, no matter on + or -, now start from pos 0
                ### [4] seq on +
                if ($tempdata[2]=~/^gi\|/) {
                    $tempdata[2]=$';
                }
                if (defined($chrorder{$tempdata[2]})) {
                    $tempdata[3]++;
                    $writestart=int(($tempdata[3]-$start[$chrorder{$tempdata[2]}])/$divide)+1;
                    $writeend=int(($tempdata[3]+length($tempdata[4])-1-$start[$chrorder{$tempdata[2]}])/$divide)+1;
                    if ($writestart==$writeend) {
                         if ($writestart<=$max[$chrorder{$tempdata[2]}]) {
                              $handle=join "",("output_",$tempdata[2],"_",$writestart);
                              print $handle "$temp\n";
                         }
                    } else {
                         if ($writestart<=$max[$chrorder{$tempdata[2]}]) {
                              $handle=join "",("output_",$tempdata[2],"_",$writestart);
                              print $handle "$temp\n";
                         }
                         if ($writeend<=$max[$chrorder{$tempdata[2]}]) {
                              $handle=join "",("output_",$tempdata[2],"_",$writeend);
                              print $handle "$temp\n";
                         }
                    }
                }
                $count++;
                if ($count%10000000==0) {
                    print "$count\n";
                }
                if (eof) {
                    last;
                }
         }
}
close input_data;

for ($j=0;$j<=$#chrtodo;$j++) {
       for ($i=1;$i<=$max[$j];$i++) {
             $handle=join "",("output_",$chrtodo[$j],"_",$i);
             close $handle;
       }
}

my $outfile="";
for ($j=0;$j<=$#chrtodo;$j++) {
       for ($i=1;$i<$max[$j];$i++) {
             print "Generating CAN array for $chrtodo[$j] ($i/$max[$j])\n";
             $file=join "",($chrtodo[$j],"_f",$i,".map");
             $outfile=join "",($chrtodo[$j],"_f",$i,".can");
             &turnbowtietoarray($chrtodo[$j],(($i-1)*$divide+$start[$j]),($i*$divide+$start[$j]-1),$file,$outfile);
       }
       print "Generating CAN array for $chrtodo[$j] ($max[$j]/$max[$j])\n";
       $file=join "",($chrtodo[$j],"_f",$max[$j],".map");
       $outfile=join "",($chrtodo[$j],"_f",$max[$j],".can");
       &turnbowtietoarray($chrtodo[$j],(($max[$j]-1)*$divide+$start[$j]),$end[$j],$file,$outfile);
}

my $line="";
my $input_file="";
open (output_result, ">./CAN/$ARGV[1]") or die "Couldn't open: $!";
for ($j=0;$j<=$#chrtodo;$j++) {
       print "Exporting result for $chrtodo[$j]\n";
       for ($i=1;$i<=$max[$j];$i++) {
             $input_file=join "",($chrtodo[$j],"_f",$i,".can");
             open (input_data, "<$input_file") or die "Couldn't open: $!";
             if (-s "./$input_file") {
                  while (1) {
                         chomp ($line=<input_data>);
                         print output_result "$line\n";
                         if (eof) {
                             last;
                         }
                  }
             }
             close input_data;
             system ("rm ./$input_file");
       }
}
close output_result;

my $average=0;
open (output_log, ">>./CAN/log.txt") or die "Couldn't open: $!";
if ($#ARGV==2) {
      print output_log "Specified region = whole genome\n";
      print ("Specified region = whole genome\n");
} elsif ($#ARGV==3) {
      print output_log "Specified region = $ARGV[3] full length\n";
      print ("Specified region = $ARGV[3] full length\n");
} else {
      print output_log "Specified region = $ARGV[3] $ARGV[4] ~ $ARGV[5]\n";
      print ("Specified region = $ARGV[3] $ARGV[4] ~ $ARGV[5]\n");
}
print output_log "Total size = $genomesize\n";
print ("Total size = $genomesize\n");
$average=int($covered/$genomesize*1000+0.5)/10;
print output_log "Covered = $covered ($average%)\n";
print ("Covered = $covered ($average%)\n");

for ($i=0;$i<=9;$i++) {
      $average=int($cover[$i]/$genomesize*1000+0.5)/10;
      $temp=join "~",($i*10,$i*10+10);
      print output_log "\tcoverage $temp = $cover[$i] ($average%)\n";
}
$average=int($cover[10]/$genomesize*1000+0.5)/10;
$temp=join "~",(100,"more");
print output_log "\tcoverage $temp = $cover[10] ($average%)\n";

$average=int($totalcoverage/$genomesize*10+0.5)/10;
print output_log "Average coverage (all) = $average\n";
$average=int($totalcoverage100/$genomesize100*10+0.5)/10;
print output_log "Average coverage (<100) = $average\n";
print ("Average coverage (<100) = $average\n");
close (output_log);


exit;







